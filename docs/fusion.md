# Block Fusion Guide

## Overview

Infernum's fusion system lets you write model code as readable, decomposed ops
and have fused CUDA kernels auto-substituted in release builds. No changes to
model code required — the optimizer handles dispatch.

### How it works

```
define_block!    →  generates decomposed fn + OnceLock static + dispatcher
define_fusion!   →  registers a fused replacement via inventory
fusion::init()   →  called once at startup, populates all OnceLock statics
```

In **debug** builds the dispatcher always calls the decomposed version (zero
overhead — the `OnceLock` is never checked). In **release** builds it checks
the `OnceLock` and dispatches to the fused version if one was registered.

Feature flags override this:

| Flag | Effect |
|------|--------|
| `force-fuse` | Use fused even in debug builds |
| `no-fuse` | Use decomposed even in release builds |

---

## Step-by-step: adding a fused op

We'll walk through a complete example — fusing `add` + `rms_norm` into a
single kernel (this is the real `add_rmsnorm` fusion in the codebase).

### 1. Write the CUDA kernel

Create `infernum/kernels/add_rmsnorm.cu`. The build script auto-discovers all
`.cu` files — no manual registration needed.

```cuda
extern "C" __global__ void add_rmsnorm_f32(
    float* __restrict__ sum_out,
    float* __restrict__ norm_out,
    const float* __restrict__ residual,
    const float* __restrict__ x,
    const float* __restrict__ weight,
    const int hidden_size,
    const float eps
) {
    // ... single kernel doing add + rmsnorm in one pass
}
```

### 2. Define the block (decomposed form)

Create `infernum/src/cuda/ops/add_rmsnorm.rs`. The `define_block!` macro wraps
a function that calls existing ops. This is the readable "source of truth":

```rust
use crate::cuda::CudaTensor;
use crate::Result;

infernum_macros::define_block! {
    pub fn add_rmsnorm(
        residual: &CudaTensor<f32>,
        x: &CudaTensor<f32>,
        weight: &CudaTensor<f32>,
        eps: f32,
    ) -> Result<(CudaTensor<f32>, CudaTensor<f32>)> {
        let sum = super::add(residual, x)?;
        let normed = super::rms_norm(&sum, weight, eps)?;
        Ok((sum, normed))
    }
}
```

This generates three items:

| Generated item | Purpose |
|---|---|
| `add_rmsnorm_decomposed(...)` | The original function body, always available |
| `ADD_RMSNORM_FUSED` | `OnceLock<fn(...)>` static — slot for the fused replacement |
| `add_rmsnorm(...)` | Dispatcher that checks `OnceLock`, falls back to decomposed |

### 3. Define the fusion (fused kernel wrapper)

In the same file (or a separate file — fusions can live anywhere, even in other
crates), register the fused replacement:

```rust
const PTX: &str = include_str!(concat!(env!("OUT_DIR"), "/kernels/add_rmsnorm.ptx"));

infernum_macros::define_fusion! {
    block: ADD_RMSNORM_FUSED,
    fn add_rmsnorm_fused(
        residual: &CudaTensor<f32>,
        x: &CudaTensor<f32>,
        weight: &CudaTensor<f32>,
        eps: f32,
    ) -> Result<(CudaTensor<f32>, CudaTensor<f32>)> {
        // Launch the fused CUDA kernel here
        // ...
    }
}
```

The `block:` path points to the `OnceLock` static generated by `define_block!`.
If the fusion is in the same file, use the bare name (`ADD_RMSNORM_FUSED`). If
it's in a different module, use the full path (`super::ADD_RMSNORM_FUSED`).

**Key rule:** the fused function must have the **exact same signature** as the
block — same parameter types and return type.

### 4. Wire it into the module

In `infernum/src/cuda/ops/mod.rs`, add the module and exports:

```rust
mod add_rmsnorm;
pub use add_rmsnorm::{add_rmsnorm, ADD_RMSNORM_FUSED};
```

The `ADD_RMSNORM_FUSED` static must be exported so that `define_fusion!` (which
may live in a different module or crate) can reference it.

### 5. Use it in model code

In the model, just call the block function. No special dispatch code needed:

```rust
// Before (separate ops):
let hidden = add(hidden, &attn_output)?;
let normed = rms_norm(&hidden, &weight, eps)?;

// After (fusible block):
let (hidden, normed) = add_rmsnorm(hidden, &attn_output, &weight, eps)?;
```

The dispatcher handles the rest — decomposed in debug, fused in release.

### 6. Add tests

Test both the decomposed and fused versions, and verify they produce matching
results:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decomposed() {
        // Call add_rmsnorm_decomposed directly, verify correctness
    }

    #[test]
    fn test_fused_matches_decomposed() {
        // Call both, compare outputs within tolerance
    }
}
```

---

## Cross-crate fusions

Fusion rules can live in any crate that depends on `infernum`. The `inventory`
crate collects registrations at link time across crate boundaries. This means
a downstream crate can provide a fused kernel for a block defined in `infernum`:

```rust
// In some external crate:
infernum_macros::define_fusion! {
    block: infernum::cuda::ops::ADD_RMSNORM_FUSED,
    fn my_fast_add_rmsnorm(...) -> ... { ... }
}
```

Just make sure:
- The crate depends on `infernum` and `infernum-macros`
- The block's `OnceLock` static is `pub` and exported
- `fusion::init()` is called at startup (the engine does this automatically)

---

## Existing fusions

| Block | Decomposed ops | Fused kernel | Location |
|-------|---------------|-------------|----------|
| `attention_kv` | transpose → repeat_kv → matmul → scale → softmax → matmul → transpose | `fused_attention_decode` / `fused_attention_prefill` | `ops/attention.rs` + `ops/fused_attention.rs` |
| `add_rmsnorm` | `add` → `rms_norm` | `add_rmsnorm_f32` | `ops/add_rmsnorm.rs` |
| `swiglu` | `silu` → `mul` | `silu_mul_f32` | `ops/silu.rs` |

---

## Design notes

- **`OnceLock` per block** — no global `HashMap`, no string lookups. After
  `init()`, dispatch is a single pointer read.
- **Debug = decomposed by default** — keeps debug builds fast to compile and
  easy to step through. The decomposed path is the readable "source of truth."
- **`inventory` for discovery** — fusions register themselves at link time.
  No manual list to maintain.
- **Safe to call `init()` multiple times** — `OnceLock::set` ignores duplicate
  calls.
- **Graceful fallback** — if no fusion is registered for a block, the
  dispatcher always falls back to decomposed. Nothing breaks.
